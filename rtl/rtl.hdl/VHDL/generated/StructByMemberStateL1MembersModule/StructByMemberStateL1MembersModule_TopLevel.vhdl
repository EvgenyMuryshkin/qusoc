-- PLEASE READ THIS, IT MAY SAVE YOU SOME TIME AND MONEY, THANK YOU!
-- * This file was generated by Quokka FPGA Toolkit.
-- * Generated code is your property, do whatever you want with it
-- * Place custom code between [BEGIN USER ***] and [END USER ***].
-- * CAUTION: All code outside of [USER] scope is subject to regeneration.
-- * Bad things happen sometimes in developer's life,
--   it is recommended to use source control management software (e.g. git, bzr etc) to keep your custom code safe'n'sound.
-- * Internal structure of code is subject to change.
--   You can use some of signals in custom code, but most likely they will not exist in future (e.g. will get shorter or gone completely)
-- * Please send your feedback, comments, improvement ideas etc. to evmuryshkin@gmail.com
-- * Visit https://github.com/EvgenyMuryshkin/QuokkaEvaluation to access latest version of playground
--
-- DISCLAIMER:
--   Code comes AS-IS, it is your responsibility to make sure it is working as expected
--   no responsibility will be taken for any loss or damage caused by use of Quokka toolkit.
--
-- System configuration name is StructByMemberStateL1MembersModule_TopLevel, clock frequency is 1Hz, Top-level
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.Quokka.all;
entity StructByMemberStateL1MembersModule_TopLevel is
	port
	(
		-- [BEGIN USER PORTS]
		-- [END USER PORTS]
		Clock : in std_logic;
		Reset : in std_logic;
		iL1_L1OptionalValue : in unsigned (0 downto 0);
		iL1_L1RequiredValue : in std_logic;
		iL1_L20_L2OptionalValue : in unsigned (1 downto 0);
		iL1_L20_L3_L3OptionalValue : in std_logic;
		iL1_L20_L3_L3RequiredValue : in signed (15 downto 0);
		iL1_L20_L3Tuple_Item1 : in std_logic;
		iL1_L20_L3Tuple_Item2_L3OptionalValue : in std_logic;
		iL1_L20_L3Tuple_Item2_L3RequiredValue : in signed (15 downto 0);
		iL1_L21_L2OptionalValue : in unsigned (1 downto 0);
		iL1_L21_L3_L3OptionalValue : in std_logic;
		iL1_L21_L3_L3RequiredValue : in signed (15 downto 0);
		iL1_L21_L3Tuple_Item1 : in std_logic;
		iL1_L21_L3Tuple_Item2_L3OptionalValue : in std_logic;
		iL1_L21_L3Tuple_Item2_L3RequiredValue : in signed (15 downto 0);
		oL1_L1OptionalValue : out unsigned (0 downto 0);
		oL1_L1RequiredValue : out std_logic;
		oL1_L20_L2OptionalValue : out unsigned (1 downto 0);
		oL1_L20_L3_L3OptionalValue : out std_logic;
		oL1_L20_L3_L3RequiredValue : out signed (15 downto 0);
		oL1_L20_L3Tuple_Item1 : out std_logic;
		oL1_L20_L3Tuple_Item2_L3OptionalValue : out std_logic;
		oL1_L20_L3Tuple_Item2_L3RequiredValue : out signed (15 downto 0);
		oL1_L21_L2OptionalValue : out unsigned (1 downto 0);
		oL1_L21_L3_L3OptionalValue : out std_logic;
		oL1_L21_L3_L3RequiredValue : out signed (15 downto 0);
		oL1_L21_L3Tuple_Item1 : out std_logic;
		oL1_L21_L3Tuple_Item2_L3OptionalValue : out std_logic;
		oL1_L21_L3Tuple_Item2_L3RequiredValue : out signed (15 downto 0)
	);
end entity;
-- FSM summary
-- Packages
architecture rtl of StructByMemberStateL1MembersModule_TopLevel is
	-- [BEGIN USER SIGNALS]
	-- [END USER SIGNALS]
	constant HiSignal : std_logic := '1';
	constant LoSignal : std_logic := '0';
	constant Zero : std_logic := '0';
	constant One : std_logic := '1';
	-- true is a reserved name, declaration skipped
	-- false is a reserved name, declaration skipped
	constant State_sL1_L2Default : unsigned(36 downto 0) := "0000000000000000000000000000000000000";
	signal Inputs_iL1_L1OptionalValue : unsigned(0 downto 0) := (others => '0');
	signal Inputs_iL1_L1RequiredValue : std_logic := '0';
	signal NextState_sL1_L1OptionalValue : unsigned(0 downto 0) := (others => '0');
	signal NextState_sL1_L1RequiredValue : std_logic := '0';
	signal State_sL1_L1OptionalValue : unsigned(0 downto 0) := "0";
	constant State_sL1_L1OptionalValueDefault : unsigned(0 downto 0) := "0";
	signal State_sL1_L1RequiredValue : std_logic := '0';
	constant State_sL1_L1RequiredValueDefault : std_logic := '0';
	type Inputs_iL1_L2Array is array (0 to 1) of unsigned (36 downto 0);
	signal Inputs_iL1_L2 : Inputs_iL1_L2Array := (others => (others => '0'));
	type State_sL1_L2Array is array (0 to 1) of unsigned (36 downto 0);
	signal State_sL1_L2 : State_sL1_L2Array := (others => (others => '0'));
	type NextState_sL1_L2Array is array (0 to 1) of unsigned (36 downto 0);
	signal NextState_sL1_L2 : NextState_sL1_L2Array := (others => (others => '0'));
begin
	process (Clock, NextState_sL1_L1OptionalValue, NextState_sL1_L1RequiredValue, Reset)
	begin
		if rising_edge(Clock) then
			if Reset = '1' then
				State_sL1_L1OptionalValue <= State_sL1_L1OptionalValueDefault;
				State_sL1_L1RequiredValue <= State_sL1_L1RequiredValueDefault;
			else
				State_sL1_L1OptionalValue <= NextState_sL1_L1OptionalValue;
				State_sL1_L1RequiredValue <= NextState_sL1_L1RequiredValue;
			end if;
		end if;
	end process;
	process (Clock, NextState_sL1_L2, Reset)
	begin
		if rising_edge(Clock) then
			if Reset = '1' then
				for State_sL1_L2_Iterator in 0 to 1 loop
					State_sL1_L2(State_sL1_L2_Iterator) <= State_sL1_L2Default;
				end loop;
			else
				for State_sL1_L2_Iterator in 0 to 1 loop
					State_sL1_L2(State_sL1_L2_Iterator) <= NextState_sL1_L2(State_sL1_L2_Iterator);
				end loop;
			end if;
		end if;
	end process;
	process (Inputs_iL1_L1OptionalValue, Inputs_iL1_L1RequiredValue, Inputs_iL1_L2, State_sL1_L1OptionalValue, State_sL1_L1RequiredValue, State_sL1_L2)
	begin
		for NextState_sL1_L2_Iterator in 0 to 1 loop
			NextState_sL1_L2(NextState_sL1_L2_Iterator) <= State_sL1_L2(NextState_sL1_L2_Iterator);
		end loop;
		NextState_sL1_L1OptionalValue <= State_sL1_L1OptionalValue;
		NextState_sL1_L1RequiredValue <= State_sL1_L1RequiredValue;
		NextState_sL1_L1OptionalValue <= Inputs_iL1_L1OptionalValue;
		NextState_sL1_L1RequiredValue <= Inputs_iL1_L1RequiredValue;
		NextState_sL1_L2(0) <= Inputs_iL1_L2(0);
		NextState_sL1_L2(1) <= Inputs_iL1_L2(1);
	end process;
	process (iL1_L1OptionalValue, iL1_L1RequiredValue, iL1_L20_L2OptionalValue, iL1_L20_L3_L3OptionalValue, iL1_L20_L3_L3RequiredValue, iL1_L20_L3Tuple_Item1, iL1_L20_L3Tuple_Item2_L3OptionalValue, iL1_L20_L3Tuple_Item2_L3RequiredValue, iL1_L21_L2OptionalValue, iL1_L21_L3_L3OptionalValue, iL1_L21_L3_L3RequiredValue, iL1_L21_L3Tuple_Item1, iL1_L21_L3Tuple_Item2_L3OptionalValue, iL1_L21_L3Tuple_Item2_L3RequiredValue, State_sL1_L1OptionalValue, State_sL1_L1RequiredValue, State_sL1_L2)
	begin
		Inputs_iL1_L1OptionalValue <= iL1_L1OptionalValue;
		Inputs_iL1_L1RequiredValue <= iL1_L1RequiredValue;
		Inputs_iL1_L2(0)(36) <= iL1_L20_L3Tuple_Item1;
		Inputs_iL1_L2(0)(35 downto 20) <= unsigned(iL1_L20_L3Tuple_Item2_L3RequiredValue);
		Inputs_iL1_L2(0)(19) <= iL1_L20_L3Tuple_Item2_L3OptionalValue;
		Inputs_iL1_L2(0)(18 downto 3) <= unsigned(iL1_L20_L3_L3RequiredValue);
		Inputs_iL1_L2(0)(2) <= iL1_L20_L3_L3OptionalValue;
		Inputs_iL1_L2(0)(1 downto 0) <= iL1_L20_L2OptionalValue;
		Inputs_iL1_L2(1)(36) <= iL1_L21_L3Tuple_Item1;
		Inputs_iL1_L2(1)(35 downto 20) <= unsigned(iL1_L21_L3Tuple_Item2_L3RequiredValue);
		Inputs_iL1_L2(1)(19) <= iL1_L21_L3Tuple_Item2_L3OptionalValue;
		Inputs_iL1_L2(1)(18 downto 3) <= unsigned(iL1_L21_L3_L3RequiredValue);
		Inputs_iL1_L2(1)(2) <= iL1_L21_L3_L3OptionalValue;
		Inputs_iL1_L2(1)(1 downto 0) <= iL1_L21_L2OptionalValue;
		oL1_L1OptionalValue <= State_sL1_L1OptionalValue;
		oL1_L1RequiredValue <= State_sL1_L1RequiredValue;
		oL1_L20_L3Tuple_Item1 <= State_sL1_L2(0)(36);
		oL1_L20_L3Tuple_Item2_L3RequiredValue <= signed(State_sL1_L2(0)(35 downto 20));
		oL1_L20_L3Tuple_Item2_L3OptionalValue <= State_sL1_L2(0)(19);
		oL1_L20_L3_L3RequiredValue <= signed(State_sL1_L2(0)(18 downto 3));
		oL1_L20_L3_L3OptionalValue <= State_sL1_L2(0)(2);
		oL1_L20_L2OptionalValue <= State_sL1_L2(0)(1 downto 0);
		oL1_L21_L3Tuple_Item1 <= State_sL1_L2(1)(36);
		oL1_L21_L3Tuple_Item2_L3RequiredValue <= signed(State_sL1_L2(1)(35 downto 20));
		oL1_L21_L3Tuple_Item2_L3OptionalValue <= State_sL1_L2(1)(19);
		oL1_L21_L3_L3RequiredValue <= signed(State_sL1_L2(1)(18 downto 3));
		oL1_L21_L3_L3OptionalValue <= State_sL1_L2(1)(2);
		oL1_L21_L2OptionalValue <= State_sL1_L2(1)(1 downto 0);
	end process;
	-- [BEGIN USER ARCHITECTURE]
	-- [END USER ARCHITECTURE]
end architecture;
